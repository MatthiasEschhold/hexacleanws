{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Training Description","text":"<p>Please follow the package, class, and method names as described in the exercises.</p>"},{"location":"#technical-environment","title":"Technical Environment","text":""},{"location":"#java","title":"Java","text":"<ul> <li>openjdk-20 </li> <li>At least higher than version 18.</li> </ul>"},{"location":"#c-sharp","title":"C Sharp","text":"<p>Coming soon.</p>"},{"location":"#the-branch-concept-for-the-labs","title":"The Branch Concept for The Labs","text":""},{"location":"#lab-branches-for-coding-challenges","title":"Lab-Branches for Coding Challenges","text":"<p>A fresh codebase for each lab to implement the exercises.</p> <p>The exercises build on each other. You always have a fresh sample solution in the lab branches.</p> <p>Branch name pattern: lab/{versionNumber}/{labNumber}</p>"},{"location":"#solution-branches-for-comparison-and-consolidation","title":"Solution-Branches for Comparison and Consolidation","text":"<p>A possible solution for each lab.</p> <p>For each exercise there is a sample solution for comparison and consolidation.  Of course, there is not one possible solution. The tests, especially the architecture  tests, help to ensure conformance to the clean architecture pattern.</p> <p>Branch name pattern: solution/{versionNumber}/{labNumber}</p>"},{"location":"#lab-description","title":"Lab Description","text":"<p>See lab description online or  publish it local like described here based on the main branch.</p>"},{"location":"#unit-and-architecture-tests","title":"Unit and Architecture Tests","text":"<p>The demo projects contains architecture tests and unit tests to verify your implementation. For the most tasks it is necessary to uncomment unit tests, after implementing the task.  In some cases it is possible to fix or to add import statements within the unit tests.</p>"},{"location":"mkdocs/","title":"Access Lab Description with MkDocs","text":"<p>The lab description is written with MkDocs.</p> <ul> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"mkdocs/#install-mkdocs","title":"Install MkDocs","text":"<p>See MkDocs Installation Guide.</p>"},{"location":"mkdocs/#prepare-installation-on-ubuntu","title":"Prepare Installation on Ubuntu","text":""},{"location":"mkdocs/#install-python","title":"Install Python","text":"<pre><code>sudo apt-get install python3\n</code></pre>"},{"location":"mkdocs/#install-pip","title":"Install Pip","text":"<pre><code>sudo apt-get install pip\n</code></pre> <p>Check the installation: <pre><code>pip -V\n</code></pre></p>"},{"location":"mkdocs/#prepare-installation-on-windows","title":"Prepare Installation on Windows","text":""},{"location":"mkdocs/#install-python-and-pip","title":"Install Python and Pip","text":"<p>Use the windows installer available here.</p> <p>Check the installation: <pre><code>pip -V\n</code></pre></p>"},{"location":"mkdocs/#install-mkdocs_1","title":"Install MkDocs","text":"<pre><code>pip install mkdocs\n</code></pre> <pre><code>pip install mkdocs-material\n</code></pre> <pre><code>pip install mkdocs-material-extensions\n</code></pre>"},{"location":"mkdocs/#publish-lab-description-locally-with-mkdocs","title":"Publish Lab Description Locally with MkDocs","text":"<ol> <li>cd docs</li> <li>mkdocs build</li> <li>mkddocs serve</li> <li>Open in browser</li> </ol>"},{"location":"docs/lab1/lab1/","title":"Clean Architecture Pattern Fundamentals","text":""},{"location":"docs/lab1/lab1/#clean-architecture-pattern","title":"Clean Architecture Pattern","text":"<p>Look at ring model of the clean architecture pattern. Try to understand the fundamental separation of the domain and the infrastructure.</p> <p></p> <p>True or False?</p> <ol> <li>The infrastructure provides interfaces which the domain can implement.</li> <li>Adapter implementations (also known as adapters) are located within the infrastructure ring and are responsible to    integrate and access infrastructure components (e.g. file system, http in- and outbound).</li> <li>The domain only depends on use cases located in the use case ring.</li> <li>The domain provides interfaces which will be implemented by adapters.</li> <li>Use case definitions are driven by adapters.</li> <li>The use case ring connects the infrastructure and the domain.</li> <li>Use case definitions are driven by domain.</li> </ol> Solution Statement True / False              The infrastructure provides interfaces which the domain can implement.                        False                        The adapters are located within the infrastructure ring and are responsible to    integrate and access infrastructure components (e.g. file system, http in- and outbound).                        True                         The domain only depends on use cases located in the use case ring.                        True                        The domain provides interfaces which will be implemented by adapters.                        True                        Use case definitions are driven by adapters.                        False                        The use case ring connects the infrastructure and the domain.                        True                        Use case definitions are driven by domain.                        True"},{"location":"docs/lab1/lab1/#underlying-design-principles","title":"Underlying Design Principles","text":""},{"location":"docs/lab1/lab1/#common-closure-and-separation-of-concerns","title":"Common Closure and Separation of Concerns","text":"<p>The common closure principles says:</p> <p>The classes of a package should be closed together against the same kind of changes. A change that affects a package affects all the classes in that package and no other package.</p> <p>Some people also say that the common closure principle describes the single responsibility principle for packages. The reason is that the same kind of changes is in most cases related to functional or domain-related requirements.</p> <p>The conclusion is that the package should be sliced vertically by domain object and functions (e.g. vehicle or vehicle data) and not horizontally by technical characteristics (e.g. controller or services). There is another principle, the so-called separation of concerns, which describes the same idea.</p> <p>Separation of concerns:</p> <p>Separate different aspects of a problem and manage every sub-problem on its own. Based on this create semantical chunks, so that the complexity of each chunk can be handled easier.</p> <p></p>"},{"location":"docs/lab1/lab1/#single-responsibility-and-solid","title":"Single Responsibility and SOLID","text":"<p>The single responsibility principle says:</p> <p>There should never be more than one reason for a class to change!</p> <p>-Tom DeMarco &amp; Meilir Page-Jones</p> <p>In comparison to the common closure principle and separation of concerns, which affects the package level, the single responsibility principle affects the class level.</p> <p>This is also the case for the other principles of SOLID. SOLID stands for:</p> <ul> <li>Single Responsibility Principle</li> <li>Open Closed Principle</li> <li>Liskov Substitution Principle</li> <li>Interface Segregation Principle</li> <li>Dependency Inversion Principle</li> </ul> <p>During the training, we discuss the principles highlighted in bold.</p> <p>An associated goal is to separate technical and domain-related aspects within the common closure. This could be reached by class stereotypes containing a clear task, that this stereotype has to do. The collection of classes is encapsulated in a common closure. This means the application will be modularized around domain-related functionality with so-called domain modules. For the clean architecture pattern, the class stereotypes can look like follows:</p> <p></p>"},{"location":"docs/lab1/lab1/#structuring-domain-modules-within-clean-architecture","title":"Structuring Domain Modules Within Clean Architecture","text":"<p>At the top architectural level, the application is structured by domain modules.</p> <p>For the internal structure of domain modules following variants are known:</p> <ul> <li>architectural expressive</li> <li>architectural expressive domain</li> <li>rings by layers</li> </ul> <p>In this training the variant architectural expressive will be used. </p>"},{"location":"docs/lab1/lab1/#rings-as-layers","title":"Rings as Layers","text":"<p>The domain module is structured simple according to the rings of the clean architecture pattern.</p> <p></p>"},{"location":"docs/lab1/lab1/#architectural-expressive-domain","title":"Architectural Expressive Domain","text":"<p>In this variant the use case ring is separated in incoming (in) and outgoing (out) use cases. Additional, the domain ring is separared in service and model.</p> <p></p>"},{"location":"docs/lab1/lab1/#architectural-expressive","title":"Architectural Expressive","text":"<p>In this package structure variant the adapter ring is also structured according to the semantics of in and out.</p> <p></p>"},{"location":"docs/lab1/lab1/#domain-ring","title":"Domain Ring","text":""},{"location":"docs/lab1/lab1/#domain-model","title":"Domain Model","text":"Coding Task 1.1 Implement a Self-Validating Domain Model <ol> <li>Create the root entity Vehicle and place it in the designated package</li> <li>Create the value object Vin and place it in the designated package</li> <li>Ensure that the Vehicle can only be created with a valid vehicle identification number (vin)</li> <li>Override equals, so that the Vehicle is the same object when the VIN is the same</li> <li>A vehicle identification number is valid when the value follows the regex pattern below. Throw an    exception in case of validation errors.</li> </ol> VIN Regex Pattern for Java / Kotlin <pre><code>// examples\n// WP0ZZZ99ZTS392155\n// WBAOLZ99ZTS349156\n\n\"(?=.*\\\\d|=.*[A-Z])(?=.*[A-Z])[A-Z0-9]{17}\"\n</code></pre> VIN Regex Pattern for C# <pre><code>// examples\n// WP0ZZZ99ZTS392155\n// WBAOLZ99ZTS349156\n\n\"(?=.*\\d|=.*[A-Z])(?=.*[A-Z])[A-Z0-9]{17}\"\n</code></pre> Verify Task 1.1 RUN DomainRing_Task_1_1     RUN ArchitectureTest_Task_1_1"},{"location":"docs/lab1/lab1/#domain-service","title":"Domain Service","text":"Coding Task 1.2 Create the (Domain) Service for the Root Entity <ol> <li>Create the class stereotype (domain) service VehicleService and place it in the designated package</li> <li>The VehicleService should provide the method find by vin (see listings for java, kotlin and c#)</li> <li>Return a hard-coded instance of the class Vehicle with the vin</li> </ol> <pre><code>WP0ZZZ99ZTS392155\n</code></pre> Java <pre><code>public Vehicle findByVin(Vin vin){...}\n</code></pre> Kotlin <pre><code>fun findByVin(vin: Vin): Vehicle {\n...\n}\n</code></pre> C# <pre><code>public VehicleRootEntity FindByVin(Vin vin){...}\n</code></pre> Verify Task 1.2 RUN DomainRing_Task_1_2     RUN ArchitectureTest_Task_1_2"},{"location":"docs/lab2/lab2/","title":"Implementing the Ports &amp; Adapters Pattern","text":""},{"location":"docs/lab2/lab2/#dependency-injection","title":"Dependency Injection","text":"<p>The Dependency Injection Pattern is characterized as follows:</p> <p>A central component, the dependency injector, manages the lifecycle of class instances and injects these instances into several consumers.</p> <p></p> <p>Relevant types of dependency injection by example with java and spring:</p> <pre><code>import org.springframework.beans.factory.annotation.Autowired;\n\npublic class Consumer {\n\n@Autowired //field injection\nprivate DependencyOne one;\n\nprivate DependencyTwo two;\n\n@Autowired // constructor injection\npublic VehicleService(DependencyTwo two) {\nthis.two = two;\n}\n\n@Autowired //method injection\npublic void doSomething(DependencyThree three) {\nthree.doSomething();\n}\n}\n</code></pre> <p>In short, the goal of dependency injection is to reduce the coupling between a consumer and provider class by the externalization of object creation and management of the object's lifecycle. So consumers can focus on the usage of this dependency. In combination with interfaces, the consumer will be decoupled from a provider-specific implementation.</p> <p>Futher informations about dependency injection</p>"},{"location":"docs/lab2/lab2/#input-adapter-ring","title":"(Input) Adapter Ring","text":"Coding Task 2.1 Create a HTTP Input Adapter and Connect It to the Domain  The class-stereotype Controller is the place to <ul> <li>implement HTTP-based inbound into our application,</li> <li>wiring incoming use cases to execute domain functionality and,</li> <li>transform domain-related exceptions to HTTP status codes.</li> </ul> <ol> Create a VehicleController and place it in the designated package Implement the REST endpoint /vehicle/{vin} and return a hard-coded vehicle object. Use following method    signature and the below value for the vin. Ignore any framework specific annotations and configurations <pre><code>WP0ZZZ99ZTS392155\n</code></pre> </ol> Java <pre><code>public Vehicle readVehicle(String vin) {...}\n</code></pre> Kotlin <pre><code>fun readVehicle(vin: String): Vehicle {...}\n</code></pre> C# <pre><code>public VehicleRootEntity ReadVehicle(string vin) {...} </code></pre> Coding Task 2.2 Call the Domain <ol> <li>Create the incoming use case VehicleQuery with the method</li> <li>Replace the hard-coded Vehicle within VehicleController with the usage of VehicleQuery</li> <li>The dependency between VehicleController and VehicleQuery should be resolved via constructor injection</li> <li>The VehicleService should implement the usecase VehicleQuery</li> </ol> Java <pre><code>Vehicle findByVin(Vin vin);\n</code></pre> Kotlin <pre><code>fun findByVin(vin: Vin): Vehicle\n</code></pre> C# <pre><code>VehicleRootEntity FindByVin(string vin) {...} </code></pre> Verify Lab 2 RUN InputAdapter_Task_2_1_2_2  RUN ArchitectureTest_Task_2_1_2_2"},{"location":"docs/lab2/lab2/#dependency-inversion-principle","title":"Dependency Inversion Principle","text":"<p>The dependency inversion principle says:</p> <p>Abstractions should not depend on details. Details should depend on abstractions.</p> <p>The VehicleService is a concrete implementation. This means it is a detail. Following the dependency inversion principle, the VehicleService should depend on an abstraction like an interface.  This interface will be implemented by the provider of a functionality. As a result, there is no direct dependency on a  specific implementation. The dependency is inverted!</p> <p></p>"},{"location":"docs/lab2/lab2/#output-adapter-ring","title":"(Output) Adapter Ring","text":"Coding Task 2.3 Introduce a Outgoing Use Case and Create a Database Adapter     The class-stereotype Repository is the place to    <ul> <li>wire a JdbcRepository or JpaRepository,</li> <li>connect to a database with plain jdbc,</li> <li>define and execute sql statements as well as</li> <li>handle sql errors.</li> </ul> <ol> <li>Create the outgoing usecase VehicleDbQuery with the method</li> <li>Create the repository VehicleRepository and place it in the designated package</li> <li>The repository should implement VehicleDbQuery and should return a hard-coded Vehicle instance</li> <li>Replace the hard-coded Vehicle within VehicleService with the usage of VehicleDbQuery</li> <li>The dependency between VehicleService and VehicleDbQuery should be resolved via constructor injection</li> </ol> Java <pre><code>Vehicle findVehicleByVin(Vin vin);\n</code></pre> Kotlin <pre><code>fun findVehicleByVin(vin: Vin): Vehicle\n</code></pre> C# <pre><code>VehicleRootEntity FindVehicleByVin(Vin vin) {...} </code></pre> Verify 2.3 RUN OutputAdapter_Task_2_3     RUN ArchitectureTest_Task_2_3  Additional Questions and Group Discussion  For dealing with persistence aspects spring-data-jpa or spring-data-jdbc uses annotations like @Entity, @Table, @Id, @Column, etc. Often this concepts need also an empty constructor as well as setter and getters for all properties.  <pre><code>@Table(\"vehicle\")  //jdbc\n@Entity //jpa\npublic class Vehicle {\n\n@Column(\"vin\")\n@Id\nprivate Vin vin;\n\n//...\n\npublic Vehicle() {\n}\n\npublic Vehicle(Vin vin) {\n//...\n}\n\n//getter and setter\n}\n</code></pre> <ol> <li>       Regarding the above code example answer following questions:       <ol> <li>Is the domain object Vehicle decoupled from infrastructure aspects?</li> <li>Is it possible to ensure a valid creation of the domain object like implemented in Lab 1?</li> <li>Is there fully control that the domain object state stays valid over the lifetime of the object?</li> </ol> </li> <li>       Is a value object a good structure for a relational database? What are benefits of a value object like the Vin?    </li> <li>       How would you describe the relationship between dependency inversion and dependency injection?    </li> <li>       How would you describe the single responsibility principles for the following classes? Make two or three bullet       points.       <ul> <li>VehicleController,</li> <li>VehicleService,</li> <li>VehicleRepository and</li> <li>Vehicle</li> </ul> Example          The responsibility of VehicleController with the stereoytpe Controller is:          <ul> <li>...</li> <li>...</li> <li>...</li> </ul> </li> </ol>"},{"location":"docs/lab3/lab3/","title":"Mappings Between Boundaries","text":"<p>Currently, the Vehicle is the model of the application, and it is not separated from infrastructure. In conclusion the idea of ports and adapters is not consequently followed. The missing element for a fully decoupled domain from infrastructure is a mapping between these boundaries.</p> <p>Mapping</p> <p>Mappings between boundaries describes a transformation of the state of a source entity model to a target entity model. The following code snippets shows an example of different entity model, where for example the baumuster of VehicleDto must be mapped on the property modelName of Vehicle.</p> <pre><code>public class Vehicle {\n\npublic String modelName;\n\npublic String vin;\n\npublic Double mileage;\n\n}\n</code></pre> <pre><code>public class VehicleDto {\n\npublic String vehicleModel;\n\npublic String vehicleId;\n\npublic Double mileage;\n\n}\n</code></pre> <p>Pro Mapping</p> <ul> <li>         If we don't map between layers, we have to use the same model on both layers, which means that the layers will be         tightly coupled.     </li> <li> Mappings enables use to         <ol> <li>reduce the amount of data from external models,</li> <li>implement a model in our domain language, which is easier to understand and to extend</li> </ol> </li> </ul> <p>Contra Mapping</p> <ul> <li>If we do map between layers, we produce a lot of boilerplate code, which is overkill for many use cases.</li> </ul> <p>All arguments are true. We have to consider our architecture goals for this decision. Our goals are to create a isolated domain, and source code that expresses the domain functionality and language. A key element to reach this is mapping. A good balance between boilerplate code and decoupling can be reached by simplifying and automating mappings based on the so-called Two-Way Mapping Strategy.</p>"},{"location":"docs/lab3/lab3/#data-transfer-objects-between-layers","title":"Data Transfer Objects Between Layers","text":"<p>The class-stereotype Data Transfer Object described data objects provided by infrastructure components. In detail Data Transfer Object can be a:</p> <ul> <li>DbEntity</li> <li>Event</li> <li>Resource</li> <li>Response Object</li> <li>and so on</li> </ul>"},{"location":"docs/lab3/lab3/#benefits-of-mappings","title":"Benefits of Mappings","text":"<p>Stable Domain and Fast Adaption</p> <p>Changes to the infrastructure do not affect the domain. For example an external service changes its response model then the changes affect only the mapper of the adapter. This single point of change enables us to adapt fast to infrastructure changes.</p> <p>In addition to that, it is possible to reduce test efforts. There are no tests of the domain needed when nothing changed. The adapter implementation could be tested in isolation on a pure technical level, which is less complex and cost-intensive.</p> <p>Evolutionary Design</p> <p>Change comes fast and unexpected. But for sure it comes! Domain-related change could arise due to</p> <ul> <li>changing behaviour,</li> <li>new requirements,</li> <li>growing business model,</li> <li>changing business model,</li> <li>new consumers,</li> <li>and so on.</li> </ul> <p>Since we cannot foresee change, we must look ahead and act. On an architectural level, this means that we have to apply architecture and design principle that enables change.</p> <p>The idea of ports and adapters is a powerful pattern to support change based on the decoupling of domain and infrastructure. Each of them can grow, modernize and tested independently.</p>"},{"location":"docs/lab3/lab3/#output-adapter","title":"Output Adapter","text":"Coding Task 3.1 Introduce a DbEntity <ol> <li>Create the class VehicleDbEntity and place it in the designated package</li> <li>Ignore framework specific annotations like discussed in the previous lab</li> </ol> Java <pre><code>public class VehicleDbEntity {\n\n//id\nprivate String vin;\n\n//getter and setter\n}\n</code></pre> Kotlin <pre><code>class VehicleDbEntity {\n\n//id\nvar vin: String? = null\n\n}\n</code></pre> C# <pre><code>public class VehicleDbEntity {\n\n//id\nprivate string Vin {get; set;};\n\n}\n</code></pre> Verify 3.1 RUN DbEntity_Task_3_1      RUN ArchitectureTest_Task_3_1"},{"location":"docs/lab3/lab3/#vehiclerepository-vehicledbentity-and-mapping-between-output-adapter-and-domain","title":"VehicleRepository, VehicleDbEntity and Mapping between Output Adapter and Domain","text":"Coding Task 3.2 Extend the VehicleRepository <ol> <li>     Add the private method findVehicleDbEntity to VehicleRepository which returns a hard coded VehicleDbEntity </li> <li>     Use findVehicleDbEntity in the existing public method findVehicleByVin and replace the hard code Vehicle     creation </li> </ol> Java <pre><code>private VehicleDbEntity findVehicleDbEntity(Vin vin){ ... }\n</code></pre> Kotlin <pre><code>private fun findVehicleDbEntity(vin: Vin): VehicleDbEntity {...}\n</code></pre> C# <pre><code>private VehicleDbEntity FindVehicleDbEntity(Vin vin){ ... }\n</code></pre>   As a result you have a compiltation error.  Introduce a Mapper <ol> <li>     Introduce the VehicleToVehicleDbEntityMapper with the following method and fix the compilation error. </li> </ol> Java <pre><code>public Vehicle mapVehicleDbEntityToVehicle(VehicleDbEntity dbEntity){...}\n</code></pre> Kotlin <pre><code>fun mapVehicleDbEntityToVehicle(dbEntity: VehicleDbEntity): Vehicle{...}\n</code></pre> C# <pre><code>public VehicleRootEntity MapVehicleDbEntityToVehicle(VehicleDbEntity dbEntity){...}\n</code></pre> Verify 3.2 COMMENT IN method createVehicleDbEntity in class TestObjectFactory  COMMENT IN method createVehicleRepository in class TestObjectFactory  RUN Mapper_Task_3_2  RUN OutputAdapter_Task_3_2  RUN ArchitectureTest_Task_3_2"},{"location":"docs/lab3/lab3/#vehiclecontroller-vehicleresource-and-mapping-between-input-adapter-and-domain","title":"VehicleController, VehicleResource and Mapping between Input Adapter and Domain","text":"Coding Task 3.3 Extend the VehicleController with a Resource  Change the method read vehicle with the vin as input parameter to   Java <pre><code>public VehicleResource readVehicle(String vin);\n</code></pre> Kotlin <pre><code>fun readVehicle(vin: String): VehicleResource;\n</code></pre> C# <pre><code>public VehicleResource ReadVehicle(string vin);\n</code></pre>   Now a compilation error occur in the VehicleController.  <ol> <li> Implement the class VehicleResource and, </li> <li> a mapper class with the name VehicleToVehicleResourceMapper which uses MapStruct </li> </ol> Java  Sources for MapStruct: <ul> <li>MapStruct Basics</li> <li>Custom Mapper with MapStruct</li> <li>MapStruct Reference Guide Version 1.5.3</li> <li>Other sources</li> </ul> C#  Sources for AutoMapper: <ul> <li>AutoMapper Tutorial</li> <li> AutoMapper Documentation</li> </ul> Verify 3.3 COMMENT IN method createExpectedVehicleResource in class TestObjectFactory  RUN InputAdapter_Task_3_3  RUN ArchitectureTest_Task_3_3  Addtional Verification for Java RUN Mapper_Task_3_3"},{"location":"docs/lab4/lab4/","title":"The Domain Grows Part I","text":""},{"location":"docs/lab4/lab4/#implement-the-domain-model","title":"Implement the Domain Model","text":"Coding Task 4.1  Understand the domain object graph of Vehicle and implement the missing validation rules  described in the table below.   Value Object Validation Rules Domain Object Validation Rule LicensePlate A-Z\u00d6\u00dc\u00c4]{1,3}-[A-Z\u00d6\u00dc\u00c4]{1,2} [1-9]{1}[0-9]{1,3} EquipmentCode [A-Z]{2}[0-9]{3} Mileage no negative value (mileage &gt;= 0) Root Entity Validation Rules Domain Object Validation Rule VehicleMotionData All fields are mandatory, all values must fulfil the validation rules Vehicle Vin, Vehicle Masterdata are mandatory Verify 4.1 COMMENT IN method createExpectedVehicleMotionData in class SimpleTestObjectFactory  RUN DomainRing_Task_4_1  RUN ArchitectureTest_Task_4_1"},{"location":"docs/lab4/lab4/#extend-the-input-adapter","title":"Extend the Input Adapter","text":"Coding Task 4.2  Investigate the VehicleResource and adapt the VehicleToVehicleResourceMapper,  so that all properties will be mapped.   Verify 4.2 RUN InputAdapter_Task_4_2  RUN all architecture tests"},{"location":"docs/lab4/lab4/#introduce-the-vehiclemasterdataserviceclient","title":"Introduce the VehicleMasterDataServiceClient","text":"Coding Task 4.3 and Group Discussion  There are some constraints given by the company context. There is one central system for  vehicle master data. This system provides the necessary master data.   Due to this, the adapter implementation based on the classes VehicleMasterDataServiceClient  and VehicleMasterDataToVehiceDtoMapper (package vehicle/adapter/out/dto) as well as the  outgoing use case (package vehicle/usecase/out) are introduced.  The external API returns a lot of information we do not need in our domain. This is visible in the VehicleDataDto class. For example the property salesRelatedInformation is not needed  in our domain. Due to this we only extract the properties we defined in the VehicleMasterData domain object.   Understand the architecture, code and motivation beyond. Discuss it in the group.  [//]: # ( <p>)</p>"},{"location":"docs/lab4/lab4/#extend-the-output-adapter","title":"Extend the Output Adapter","text":"Coding Task 4.4  The vehicle motion data and other information that not belongs to vehicle master data, will  be stored in the database of our application. This means we are owner of data and state for  vehicle motion data.  Extend the VehicleDbEntity and the VehicleToVehicleDbEntityMapper as described in the diagram.   Verify 4.4 RUN OutputAdapter_Task_4_4  RUN all architecture tests"},{"location":"docs/lab4/lab4/#extend-the-vehicleservice","title":"Extend the VehicleService","text":"Coding Task 4.5  Extend the VehicleService, so that vehicle motion data will be queried from database, and  vehicle master data will be queried from the central company vehicle master data service. Use the use case FetchVehicleMasterData.   Verify 4.5 RUN OutputAdapter_Task_4_5  RUN all architecture tests"},{"location":"docs/lab5/lab5/","title":"The Domain Grows Part II","text":""},{"location":"docs/lab5/lab5/#slicing-use-cases-with-the-interface-segregation-principle","title":"Slicing Use Cases with the Interface Segregation Principle","text":"<p>Robert C. Martin points out in his book Clean Architecture that</p>  depending on something that carries baggage that you don't need can cause you trouble that you didn't expect!  <p>The Interface Segregation Principle provides an answer to this problem. It states that broad  interfaces should be split into specific ones so that clients only know the methods they need.</p> <p>Applying the Interface Segregation Principle</p> <ul> <li>removes unnecessary dependencies to methods the consumer doesn't need,</li> <li>makes the existing dependencies more visible,</li> <li>prevents potential trouble based on side effects and,</li> <li>enables extendibility and flexibility </li> </ul> <p>In origin sense the Interface Segregation Principle says:</p> <p>Many client-specific interfaces increase readability and understandability compared to one general-purpose interface.  No clients should be forced to depend on methods it does not use. In conclusion, interfaces should be separated into small  responsibilities as minimalistic as possible.</p> <p></p> <p>Personally I do not use the option Root Entity. As a default I use the option Command &amp; Query. When different consumer exists and there are difference between their needs, then I recommend using the option One Method Per Use Case (Port). Also referring to the package structure variants, there is a separation of incoming and outgoing use cases, which is recommended to apply as standard design principle.</p> <p>Following code examples shows different variants of slicing use cases.</p> <p>Use Cases by Root Entity</p> <pre><code>public interface VehicleUseCase {\n\nVehicle readByVin(Vin vin);\n\nVehicle readByLicensePlate(LicensePlate licensePlate);\n\nVehicle update(Vin vin, VehicleMotionData vehicleMotionData);\n\nVehicle create(Vehicle vehicle);\n\nvoid delete(Vin vin);\n}\n</code></pre> <p>Use Case by Separating Command and Query</p> <pre><code>public interface VehicleQuery {\n\nVehicle readByVin(Vin vin);\n\nVehicle readByLicensePlate(LicensePlate licensePlate);\n}\n</code></pre> <pre><code>public interface VehicleCommand {\n\nVehicle update(Vin vin, VehicleMotionData vehicleMotionData);\n\nVehicle create(Vehicle vehicle);\n\nvoid delete(Vin vin);\n}\n</code></pre> <p>A separation in Command and Query helps to prevent, that classes grow into complex and big units of code that are hard to understand. A good orientation for modularisation inside a domain module can be found in Command and Query, even when you do not plan to apply the Command Query Segregation Principle.  But we can create a good foundation for such an evolution.</p> <p>One Method per Use Case (Port)</p> <pre><code>public interface ReadVehicleByVin {\n\nVehicle read(Vin vin);\n}\n</code></pre> <pre><code>public interface ReadVehicleByLicensePlate {\n\nVehicle read(LicensePlate licensePlate);\n}\n</code></pre> <pre><code>public interface CreateVehicle {\n\nVehicle readByVin(Vin vin);\n\nVehicle readByLicensePlate(LicensePlate licensePlate);\n}\n</code></pre> <pre><code>public interface UpdateVehicle {\n\nVehicle update(Vin vin, VehicleMotionData vehicleMotionData);\n}\n</code></pre> <pre><code>public interface DeleteVehicle {\n\nvoid delete(Vin vib);\n}\n</code></pre> <p>Even when the variant One Method per Use Case is not typical Java, slicing use cases this way reduces coupling between clients. In conclusion, the overall coupling between components of the software system will be kept low. Coupling rises quickly and unavoidable. Due to this, we should avoid it every time when possible, especially in fast-growing software systems for complex business domains.</p> <p>Small sliced use cases allow assembling these use cases to a higher composition of functionality. Based on this, functionality can be extended fast for new or changing business processes or user group specific requirements.</p>"},{"location":"docs/lab5/lab5/#slicing-use-cases-in-practice","title":"Slicing Use Cases in Practice","text":"<p>There is no right way by default. It depends on complexity and specific requirements of the project.  In practice a reasonable combination of these variants is may the best way to find a good balance between flexibility and  simplicity in the architecture in the long term.</p> <p>Let's have a look on following functional requirements. As we already know, we have the mission to build a great garage management that is maintainable, extendable and flexible. We want to modernize existing business processes and establish new business models. And the system now starts to live, and we can expect an evolution over the years because the business model change over time due to changing requirements of the stakeholder as well as technical evolution, which creates the need of modernization.</p>"},{"location":"docs/lab5/lab5/#refactor-vehicleservice-and-vehiclerepository","title":"Refactor VehicleService and VehicleRepository","text":"Coding Task 5.1 Now it will be clear, why we named the already implemented use cases the way we did. The next step is to make the separation more clear in our current implementation.  Rename the <ul> <li> VehicleService to VehicleQueryService </li> <li> VehicleRepository to VehicleQueryRepository </li> </ul> Verify 5.1 RUN OutputAdapter_Task_5_1     RUN DomainRing_Task_5_1      Java &amp; Kotlin       The CleanArchitectureTest located in src/test/java/de/arkem/hexaclean/arc/demo/lab/test is a generic test for checking       the architecture rules of the clean architecture pattern based on [ArchUnit](https://www.archunit.org/).        RUN CleanArchitectureTest        RUN all (other) architecture tests     C# RUN all architecture tests"},{"location":"docs/lab5/lab5/#introduce-vehiclecommand-and-vehicledbcommand","title":"Introduce VehicleCommand and VehicleDbCommand","text":"Coding Task 5.2    In the next step, we want to introduce functionality to create a vehicle and update the vehicle motion data.    <ol> <li>          Introduce the incoming use case VehicleCommand that provides the methods create and update </li> <li>          Introduce the VehicleCommandService and implement VehicleCommand </li> <li>          Introduce the outgoing use case VehicleDbCommand that provides the method save </li>          Introduce the VehicleCommandRepository and implement the VehicleDbCommand <li>          Extend the VehicleToVehicleDbEntityMapper  with the necessary mappings       </li> <li>          Extend the VehicleController with REST interface for create and update.           Use the VehicleCommand to connect to the domain.       </li> <li>          Extend the VehicleToVehicleResourceMapper with the necessary mappings       </li> <li>          Consider always placing all classes it in the designated packages.       </li> </ol> VehicleCommand Java <pre><code>Vehicle create(Vehicle vehicle);\nVehicle update(Vin vin,VehicleMotionData vehicleMotionData);\n</code></pre> Kotlin <pre><code>fun create(vehicle: Vehicle): Vehicle\nfun update(vin: Vin, vehicleMotionData: VehicleMotionData): Vehicle\n</code></pre> C# <pre><code>Vehicle Create(Vehicle vehicle);\nVehicle Update(Vin vin, VehicleMotionData vehicleMotionData);\n</code></pre> VehicleDbCommand Java <pre><code>Vehicle save(Vehicle vehicle);\n</code></pre> Kotlin <pre><code>fun save(vehicle: Vehicle): Vehicle\n</code></pre> C# <pre><code>Vehicle Save(Vehicle vehicle);\nVehicle Update(Vin vin, VehicleMotionData vehicleMotionData);\n</code></pre> VehicleController Java <pre><code>VehicleResource create(VehicleResource vehicle);\nVehicleResource update(String vin,VehicleMotionDataResource vehicleMotionData);\n</code></pre> Kotlin <pre><code>fun save(vehicle: Vehicle): Vehicle\n</code></pre> C# <pre><code>Vehicle Save(Vehicle vehicle);\n</code></pre> Verify 5.2 RUN CleanArchitectureTest (Java &amp; Kotlin)     RUN all architecture tests"},{"location":"docs/lab5/lab5/#rich-vs-anemic-domain-model","title":"Rich vs. Anemic Domain Model","text":"<p>Based on the functionality if a vehicle supports a 5G connection, a comparison between a rich or anemic domain model will be discussed. Let's imaging the fact if a vehicle supports 5G or not can be derived from the equipment list. If there is a 5G modul built-in, then the vehicle supports 5G.</p> <p>This simplified code snippet should make the scenario more clear:</p> <pre><code>boolean determine5GSupport(List&lt;Equipment&gt; equipmentList){\nfor(Equipment equipment:equipmentList){\nif(equipment.getCode().equals(\"GS500\")){\nreturn true;\n}\n}\nreturn false;\n}\n</code></pre>"},{"location":"docs/lab5/lab5/#rich-domain-model-data-validation-and-behaviour","title":"Rich Domain Model - Data, Validation and Behaviour","text":"Coding Task 5.3 Currently, our domain model contains data and validation. Now the functionality to determine 5G support will be added as additional behaviour. The determination can be done without any additional dependencies. So it is possible to integrate the behaviour within the domain model.    <ol> <li>Add the boolean property _has5GSupport_ to the _Vehicle_ and _VehicleResource_ class</li> <li>Extend the VehicleToVehicleResourceMapper</li> <li>Implement the behaviour for has5GSupport</li> <li>Trigger the behaviour during object creation or as soon as the equipment list will changed</li> </ol> Verify 5.3 RUN DomainRing_Task_5_3      RUN DomainRing_Task_4_5     RUN CleanArchitectureTest (Java &amp; Kotlin)     RUN all architecture tests"},{"location":"docs/lab5/lab5/#optional-clean-domain-model-with-full-mapping-strategy","title":"Optional: Clean Domain Model with Full Mapping Strategy","text":"<p>Use the branch lab/{versionnumber}/lab5-full-mapping.</p> Optional Coding Task 5.5 Let's change the scenario a little. For our domain the equipment list is not relevant. We need this only to determine the enriched domain value has5GSupport.   We are very accurate and want to create an absolutely clean domain model.  When our domain does not have to know a equipment list, then the Vehicle should not contain it.   Implement this simplified scenario to get a feeling about decoupling domain logic from infrastructure  in more complex scenarios by using the Full Mapping Strategy.   Look in the package vehicle/domain/dto. The so-called DomainDTO differs from the DTO  of an infrastructure component like a DbEntity or Resource. The DomainDTO is used to decouple  a external DTO from the domain model, when this is only possible with an additional ring and mapping between  all these rings.  <ol> <li>       Remove the property equipmentList of Vehicle class    </li> <li>       Remove the domain objects Equipment and EquipmentCode </li> <li>       Remove the property equipmentList in VehicleResource </li> <li>       Move the method determine5GSupport to VehicleQueryService (or to a dedicated domain service)    </li> <li>       Adapt the constructor of Vehicle, so that the property has5GSupport is part of it.    </li> <li>       Change the return value of the use case FetchVehicleMasterData to VehicleMasterDataDomainDTO </li> <li>       Adapt the mapper VehicleToVehicleDataDtoMapper </li> <li>       Adapt the orchestration within the method findByVin of VehicleQueryService </li> <li>       Fix the compilation errors in existing unit tests     </li> </ol> Verify 5.5 RUN all unit tests     RUN CleanArchitectureTest (Java &amp; Kotlin)     RUN all architecture tests"},{"location":"docs/lab6/lab6/","title":"The Domain Grows Part III","text":""},{"location":"docs/lab6/lab6/#new-domain-modules","title":"New Domain Modules","text":"<p>Investigate the introduced domain modules GarageOrder and PartsCatalogue. Both domain modules  depends on the Vehicle domain module.</p> <p>In context of the garage order only the license plate and, the mileage of a vehicle are relevant. </p> <p>For the parts catalogue only the vin, the vehicle model and, the domain value has5GSupport  are from importance.</p> <p>See the garage order form for more details:</p> <p></p> <p>See also the explosion chart of the front brake, as a example for the graphical visualization of a spare part in the parts catalogue:</p> <p></p> <p>Additional information are described in the corresponding spare parts table.</p> <p></p>"},{"location":"docs/lab6/lab6/#design-dependencies-between-domain-modules","title":"Design Dependencies Between Domain Modules","text":"<p>In a traditional data-centric and layered architecture, it is common to design the application around a centric data model.  But this leads to high coupling in the long term (see section \"Problems of Layered Architecture\" in the trainings slides).  In this lab the Adapter.Out - UseCase.In Pattern and the Application Service Pattern are described. Additional approaches are shown in the training slides.</p>"},{"location":"docs/lab6/lab6/#the-adapterout-usecasein-pattern","title":"The Adapter.Out - UseCase.In Pattern","text":"<p>Implement the Adapter.Out - UseCase.In Pattern between the domain modules Garage order and Vehicle.</p>"},{"location":"docs/lab6/lab6/#introduce-the-use-case-fetchvehiclebylicenseplate-vehicle-module","title":"Introduce the Use Case FetchVehicleByLicensePlate (Vehicle Module)","text":"Coding Task 6.1 <ol> <li>          Introduce an additional incoming use case in the domain module Vehicle with the name           FetchVehicleByLicensePlate. The use case should contain the method fetchByLicensePlate </li> <li>          Implement the use case by extending the VehicleQueryService.       </li> </ol> Java <pre><code>Vehicle fetchByLicensePlate(LicensePlate licensePlate);\n</code></pre> Kotlin <pre><code>fun fetchByLicensePlate(licensePlate: LicensePlate): Vehicle;\n</code></pre> C# <pre><code>Vehicle FetchByLicensePlate(LicensePlate licensePlate);\n</code></pre> Verify 6.1 RUN DomainRing_Task_6_1     RUN ArchitectureTest_Task_6_1 (Java &amp; Kotlin)     RUN all architecture tests (C#)"},{"location":"docs/lab6/lab6/#implement-the-use-case-fetchvehicle-garage-order-module","title":"Implement the Use Case FetchVehicle (Garage Order Module)","text":"Coding Task 6.2 <ol> <li>          Have a look at the outgoing use case FetchVehicle in garage/order/usecase/out </li> <li>          Implement the output adapter with the name VehicleModuleClient and a mapper with the name           VehicleToOriginVehicleMapper.       </li> </ol> Verify 6.2 RUN OutputAdapter_Task_6_2     RUN ArchitectureTest_Task_6_2 (Java &amp; Kotlin)     RUN all architecture tests (C#)"},{"location":"docs/lab6/lab6/#the-application-service-pattern","title":"The Application Service Pattern","text":"Coding Task 6.3 Implement the Application Service Pattern between the domain modules Parts Catalogue and Vehicle. <ol> <li>       Have a look at the ExplosionChartApplicationService in parts/catalogue/appservice and notice the dependency to       VehicleQuery of the domain module vehicle.    </li> <li>         Complete the implementation of the use case ExplosionChartQuery in ExplosionChartQueryService </li> <li>         Use VehicleQuery from the vehicle module to fetch necessary vehicle data    </li> <li>         Implement and use the mapper VehicleToOriginVehicleMapper </li> </ol> Verify 6.3 RUN ApplicationService_Task_6_3     RUN ArchitectureTest_Task_6_3 (Java &amp; Kotlin)     RUN all architecture tests (C#)"},{"location":"docs/lab6/lab6/#clean-architecture-fitness-functions-currently-not-working","title":"Clean Architecture Fitness Functions - Currently Not Working","text":"Optional Coding Task 6.4 <ol> <li> RUN CleanArchitectureTest    </li> <li>       Fix the test by extending the test should_check_clean_architecture_all_rings_architectural_expressive </li> <li> RUN CleanArchitectureTest again. Why did the test pass now?    </li> </ol> Java &amp; Kotlin <pre><code>.adapterOutOfAdapterOutUseCaseInPattern(\"..garage.order.adapter.out..\")\n.applicationService(\"..parts.catalogue.appservice..\")\n</code></pre>"}]}